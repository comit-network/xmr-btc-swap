Index: monero-harness/src/rpc/monerod.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>use crate::{\n    rpc::{Request, Response},\n    BlockHeader,\n};\n\nuse anyhow::Result;\nuse reqwest::Url;\nuse serde::{Deserialize, Serialize};\n\n// #[cfg(not(test))]\n// use tracing::debug;\n//\n// #[cfg(test)]\nuse std::eprintln as debug;\n\n/// RPC client for monerod and monero-wallet-rpc.\n#[derive(Debug, Clone)]\npub struct Client {\n    pub inner: reqwest::Client,\n    pub url: Url,\n}\n\nimpl Client {\n    /// New local host monerod RPC client.\n    pub fn localhost(port: u16) -> Self {\n        let url = format!(\"http://127.0.0.1:{}/json_rpc\", port);\n        let url = Url::parse(&url).expect(\"url is well formed\");\n\n        Self {\n            inner: reqwest::Client::new(),\n            url,\n        }\n    }\n\n    pub async fn generate_blocks(\n        &self,\n        amount_of_blocks: u32,\n        wallet_address: &str,\n    ) -> Result<GenerateBlocks> {\n        let params = GenerateBlocksParams {\n            amount_of_blocks,\n            wallet_address: wallet_address.to_owned(),\n        };\n        let request = Request::new(\"generateblocks\", params);\n\n        let response = self\n            .inner\n            .post(self.url.clone())\n            .json(&request)\n            .send()\n            .await?\n            .text()\n            .await?;\n\n        debug!(\"generate blocks response: {}\", response);\n\n        let res: Response<GenerateBlocks> = serde_json::from_str(&response)?;\n\n        Ok(res.result)\n    }\n\n    // $ curl http://127.0.0.1:18081/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_block_header_by_height\",\"params\":{\"height\":1}}' -H 'Content-Type: application/json'\n    pub async fn get_block_header_by_height(&self, height: u32) -> Result<BlockHeader> {\n        let params = GetBlockHeaderByHeightParams { height };\n        let request = Request::new(\"get_block_header_by_height\", params);\n\n        let response = self\n            .inner\n            .post(self.url.clone())\n            .json(&request)\n            .send()\n            .await?\n            .text()\n            .await?;\n\n        debug!(\"get block header by height response: {}\", response);\n\n        let res: Response<GetBlockHeaderByHeight> = serde_json::from_str(&response)?;\n\n        Ok(res.result.block_header)\n    }\n\n    pub async fn get_block_count(&self) -> Result<u32> {\n        let request = Request::new(\"get_block_count\", \"\");\n\n        let response = self\n            .inner\n            .post(self.url.clone())\n            .json(&request)\n            .send()\n            .await?\n            .text()\n            .await?;\n\n        debug!(\"get block count response: {}\", response);\n\n        let res: Response<BlockCount> = serde_json::from_str(&response)?;\n\n        Ok(res.result.count)\n    }\n}\n\n#[derive(Clone, Debug, Serialize)]\nstruct GenerateBlocksParams {\n    amount_of_blocks: u32,\n    wallet_address: String,\n}\n\n#[derive(Clone, Debug, Deserialize)]\npub struct GenerateBlocks {\n    pub blocks: Vec<String>,\n    pub height: u32,\n    pub status: String,\n}\n\n#[derive(Clone, Debug, Serialize)]\nstruct GetBlockHeaderByHeightParams {\n    height: u32,\n}\n\n#[derive(Clone, Debug, Deserialize)]\nstruct GetBlockHeaderByHeight {\n    block_header: BlockHeader,\n    status: String,\n    untrusted: bool,\n}\n\n#[derive(Clone, Debug, Deserialize)]\nstruct BlockCount {\n    count: u32,\n    status: String,\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- monero-harness/src/rpc/monerod.rs	(revision f3eb59658cfc3f98ba17283a925b4a8851bc8609)
+++ monero-harness/src/rpc/monerod.rs	(date 1601358079186)
@@ -7,11 +7,10 @@
 use reqwest::Url;
 use serde::{Deserialize, Serialize};
 
-// #[cfg(not(test))]
-// use tracing::debug;
-//
+#[cfg(not(test))]
+use tracing::debug;
 // #[cfg(test)]
-use std::eprintln as debug;
+// use std::eprintln as debug;
 
 /// RPC client for monerod and monero-wallet-rpc.
 #[derive(Debug, Clone)]
Index: monero-harness/src/rpc/wallet.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>use crate::rpc::{Request, Response};\n\nuse anyhow::Result;\nuse reqwest::Url;\nuse serde::{Deserialize, Serialize};\n\n// TODO: Either use println! directly or import tracing also?\nuse std::println as debug;\n\n/// JSON RPC client for monero-wallet-rpc.\n#[derive(Debug)]\npub struct Client {\n    pub inner: reqwest::Client,\n    pub url: Url,\n}\n\nimpl Client {\n    /// Constructs a monero-wallet-rpc client with localhost endpoint.\n    pub fn localhost(port: u16) -> Self {\n        let url = format!(\"http://127.0.0.1:{}/json_rpc\", port);\n        let url = Url::parse(&url).expect(\"url is well formed\");\n\n        Client::new(url)\n    }\n\n    /// Constructs a monero-wallet-rpc client with `url` endpoint.\n    pub fn new(url: Url) -> Self {\n        Self {\n            inner: reqwest::Client::new(),\n            url,\n        }\n    }\n\n    /// Get addresses for account by index.\n    pub async fn get_address(&self, account_index: u32) -> Result<GetAddress> {\n        let params = GetAddressParams { account_index };\n        let request = Request::new(\"get_address\", params);\n\n        let response = self\n            .inner\n            .post(self.url.clone())\n            .json(&request)\n            .send()\n            .await?\n            .text()\n            .await?;\n\n        debug!(\"get address RPC response: {}\", response);\n\n        let r: Response<GetAddress> = serde_json::from_str(&response)?;\n        Ok(r.result)\n    }\n\n    /// Gets the balance of account by index.\n    pub async fn get_balance(&self, index: u32) -> Result<u64> {\n        let params = GetBalanceParams {\n            account_index: index,\n        };\n        let request = Request::new(\"get_balance\", params);\n\n        let response = self\n            .inner\n            .post(self.url.clone())\n            .json(&request)\n            .send()\n            .await?\n            .text()\n            .await?;\n\n        debug!(\n            \"get balance of account index {} RPC response: {}\",\n            index, response\n        );\n\n        let res: Response<GetBalance> = serde_json::from_str(&response)?;\n\n        let balance = res.result.balance;\n\n        Ok(balance)\n    }\n\n    pub async fn create_account(&self, label: &str) -> Result<CreateAccount> {\n        let params = LabelParams {\n            label: label.to_owned(),\n        };\n        let request = Request::new(\"create_account\", params);\n\n        let response = self\n            .inner\n            .post(self.url.clone())\n            .json(&request)\n            .send()\n            .await?\n            .text()\n            .await?;\n\n        debug!(\"create account RPC response: {}\", response);\n\n        let r: Response<CreateAccount> = serde_json::from_str(&response)?;\n        Ok(r.result)\n    }\n\n    /// Get accounts, filtered by tag (\"\" for no filtering).\n    pub async fn get_accounts(&self, tag: &str) -> Result<GetAccounts> {\n        let params = TagParams {\n            tag: tag.to_owned(),\n        };\n        let request = Request::new(\"get_accounts\", params);\n\n        let response = self\n            .inner\n            .post(self.url.clone())\n            .json(&request)\n            .send()\n            .await?\n            .text()\n            .await?;\n\n        debug!(\"get accounts RPC response: {}\", response);\n\n        let r: Response<GetAccounts> = serde_json::from_str(&response)?;\n\n        Ok(r.result)\n    }\n\n    /// Creates a wallet using `filename`.\n    pub async fn create_wallet(&self, filename: &str) -> Result<()> {\n        let params = CreateWalletParams {\n            filename: filename.to_owned(),\n            language: \"English\".to_owned(),\n        };\n        let request = Request::new(\"create_wallet\", params);\n\n        let response = self\n            .inner\n            .post(self.url.clone())\n            .json(&request)\n            .send()\n            .await?\n            .text()\n            .await?;\n\n        debug!(\"create wallet RPC response: {}\", response);\n\n        Ok(())\n    }\n\n    /// Transfers `amount` moneroj from `account_index` to `address`.\n    pub async fn transfer(\n        &self,\n        account_index: u32,\n        amount: u64,\n        address: &str,\n    ) -> Result<Transfer> {\n        let dest = vec![Destination {\n            amount,\n            address: address.to_owned(),\n        }];\n        self.multi_transfer(account_index, dest).await\n    }\n\n    /// Transfers moneroj from `account_index` to `destinations`.\n    pub async fn multi_transfer(\n        &self,\n        account_index: u32,\n        destinations: Vec<Destination>,\n    ) -> Result<Transfer> {\n        let params = TransferParams {\n            account_index,\n            destinations,\n            get_tx_key: true,\n        };\n        let request = Request::new(\"transfer\", params);\n\n        let response = self\n            .inner\n            .post(self.url.clone())\n            .json(&request)\n            .send()\n            .await?\n            .text()\n            .await?;\n\n        debug!(\"transfer RPC response: {}\", response);\n\n        let r: Response<Transfer> = serde_json::from_str(&response)?;\n        Ok(r.result)\n    }\n\n    /// Get wallet block height, this might be behind monerod height.\n    pub(crate) async fn block_height(&self) -> Result<BlockHeight> {\n        let request = Request::new(\"get_height\", \"\");\n\n        let response = self\n            .inner\n            .post(self.url.clone())\n            .json(&request)\n            .send()\n            .await?\n            .text()\n            .await?;\n\n        debug!(\"wallet height RPC response: {}\", response);\n\n        let r: Response<BlockHeight> = serde_json::from_str(&response)?;\n        Ok(r.result)\n    }\n\n    /// Check a transaction in the blockchain with its secret key.\n    pub async fn check_tx_key(\n        &self,\n        tx_id: &str,\n        tx_key: &str,\n        address: &str,\n    ) -> Result<CheckTxKey> {\n        let params = CheckTxKeyParams {\n            tx_id: tx_id.to_owned(),\n            tx_key: tx_key.to_owned(),\n            address: address.to_owned(),\n        };\n        let request = Request::new(\"check_tx_key\", params);\n\n        let response = self\n            .inner\n            .post(self.url.clone())\n            .json(&request)\n            .send()\n            .await?\n            .text()\n            .await?;\n\n        debug!(\"transfer RPC response: {}\", response);\n\n        let r: Response<CheckTxKey> = serde_json::from_str(&response)?;\n        Ok(r.result)\n    }\n\n    pub async fn generate_from_keys(\n        &self,\n        address: &str,\n        spend_key: &str,\n        view_key: &str,\n    ) -> Result<GenerateFromKeys> {\n        let params = GenerateFromKeysParams {\n            restore_height: 0,\n            filename: view_key.into(),\n            address: address.into(),\n            spendkey: spend_key.into(),\n            viewkey: view_key.into(),\n            password: \"\".into(),\n            autosave_current: true,\n        };\n        let request = Request::new(\"generate_from_keys\", params);\n\n        let response = self\n            .inner\n            .post(self.url.clone())\n            .json(&request)\n            .send()\n            .await?\n            .text()\n            .await?;\n\n        debug!(\"generate_from_keys RPC response: {}\", response);\n\n        let r: Response<GenerateFromKeys> = serde_json::from_str(&response)?;\n        Ok(r.result)\n    }\n}\n\n#[derive(Serialize, Debug, Clone)]\nstruct GetAddressParams {\n    account_index: u32,\n}\n\n#[derive(Deserialize, Debug, Clone)]\npub struct GetAddress {\n    pub address: String,\n}\n\n#[derive(Serialize, Debug, Clone)]\nstruct GetBalanceParams {\n    account_index: u32,\n}\n\n#[derive(Deserialize, Debug, Clone)]\nstruct GetBalance {\n    balance: u64,\n    blocks_to_unlock: u32,\n    multisig_import_needed: bool,\n    time_to_unlock: u32,\n    unlocked_balance: u64,\n}\n\n#[derive(Serialize, Debug, Clone)]\nstruct LabelParams {\n    label: String,\n}\n\n#[derive(Deserialize, Debug, Clone)]\npub struct CreateAccount {\n    pub account_index: u32,\n    pub address: String,\n}\n\n#[derive(Serialize, Debug, Clone)]\nstruct TagParams {\n    tag: String,\n}\n\n#[derive(Deserialize, Debug, Clone)]\npub struct GetAccounts {\n    pub subaddress_accounts: Vec<SubAddressAccount>,\n    pub total_balance: u64,\n    pub total_unlocked_balance: u64,\n}\n\n#[derive(Deserialize, Debug, Clone)]\npub struct SubAddressAccount {\n    pub account_index: u32,\n    pub balance: u32,\n    pub base_address: String,\n    pub label: String,\n    pub tag: String,\n    pub unlocked_balance: u64,\n}\n\n#[derive(Serialize, Debug, Clone)]\nstruct CreateWalletParams {\n    filename: String,\n    language: String,\n}\n\n#[derive(Serialize, Debug, Clone)]\nstruct TransferParams {\n    // Transfer from this account.\n    account_index: u32,\n    // Destinations to receive XMR:\n    destinations: Vec<Destination>,\n    // Return the transaction key after sending.\n    get_tx_key: bool,\n}\n\n#[derive(Serialize, Debug, Clone)]\npub struct Destination {\n    amount: u64,\n    address: String,\n}\n\n#[derive(Deserialize, Debug, Clone)]\npub struct Transfer {\n    pub amount: u64,\n    pub fee: u64,\n    pub multisig_txset: String,\n    pub tx_blob: String,\n    pub tx_hash: String,\n    pub tx_key: String,\n    pub tx_metadata: String,\n    pub unsigned_txset: String,\n}\n\n#[derive(Clone, Copy, Debug, Deserialize)]\npub struct BlockHeight {\n    pub height: u32,\n}\n\n#[derive(Serialize, Debug, Clone)]\nstruct CheckTxKeyParams {\n    #[serde(rename = \"txid\")]\n    tx_id: String,\n    tx_key: String,\n    address: String,\n}\n\n#[derive(Clone, Copy, Debug, Deserialize)]\npub struct CheckTxKey {\n    pub confirmations: u32,\n    pub in_pool: bool,\n    pub received: u64,\n}\n\n#[derive(Clone, Debug, Serialize)]\npub struct GenerateFromKeysParams {\n    pub restore_height: u32,\n    pub filename: String,\n    pub address: String,\n    pub spendkey: String,\n    pub viewkey: String,\n    pub password: String,\n    pub autosave_current: bool,\n}\n\n#[derive(Clone, Debug, Deserialize)]\npub struct GenerateFromKeys {\n    pub address: String,\n    pub info: String,\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- monero-harness/src/rpc/wallet.rs	(revision f3eb59658cfc3f98ba17283a925b4a8851bc8609)
+++ monero-harness/src/rpc/wallet.rs	(date 1601358253975)
@@ -5,7 +5,9 @@
 use serde::{Deserialize, Serialize};
 
 // TODO: Either use println! directly or import tracing also?
-use std::println as debug;
+// use std::println as debug;
+#[cfg(not(test))]
+use tracing::debug;
 
 /// JSON RPC client for monero-wallet-rpc.
 #[derive(Debug)]
